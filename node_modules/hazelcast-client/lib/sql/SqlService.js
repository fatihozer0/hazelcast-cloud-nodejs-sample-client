"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SqlServiceImpl = void 0;
/*
 * Copyright (c) 2008-2021, Hazelcast, Inc. All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SqlResult_1 = require("./SqlResult");
const SqlStatement_1 = require("./SqlStatement");
const core_1 = require("../core");
const SqlErrorCode_1 = require("./SqlErrorCode");
const SqlQueryId_1 = require("./SqlQueryId");
const SqlExecuteCodec_1 = require("../codec/SqlExecuteCodec");
const Long = require("long");
const SqlRowMetadata_1 = require("./SqlRowMetadata");
const SqlCloseCodec_1 = require("../codec/SqlCloseCodec");
const SqlFetchCodec_1 = require("../codec/SqlFetchCodec");
const Util_1 = require("../util/Util");
/** @internal */
class SqlServiceImpl {
    constructor(connectionRegistry, serializationService, invocationService, connectionManager) {
        this.connectionRegistry = connectionRegistry;
        this.serializationService = serializationService;
        this.invocationService = invocationService;
        this.connectionManager = connectionManager;
    }
    /**
     * Handles SQL execute response.
     * @param clientMessage The response message
     * @param res SQL result for this response
     */
    static handleExecuteResponse(clientMessage, res) {
        const response = SqlExecuteCodec_1.SqlExecuteCodec.decodeResponse(clientMessage);
        if (response.error !== null) {
            res.onExecuteError(new core_1.HazelcastSqlException(response.error.originatingMemberId, response.error.code, response.error.message));
        }
        else {
            res.onExecuteResponse(response.rowMetadata !== null ? new SqlRowMetadata_1.SqlRowMetadataImpl(response.rowMetadata) : null, response.rowPage, response.updateCount);
        }
    }
    /**
     * Validates SqlStatement
     *
     * @param sqlStatement
     * @throws RangeError if validation is not successful
     * @internal
     */
    static validateSqlStatement(sqlStatement) {
        if (sqlStatement === null) {
            throw new RangeError('SQL statement cannot be null');
        }
        Util_1.tryGetString(sqlStatement.sql);
        if (sqlStatement.sql.length === 0) { // empty sql string is disallowed
            throw new RangeError('Empty SQL string is disallowed.');
        }
        if (sqlStatement.hasOwnProperty('params')) { // if params is provided, validate it
            Util_1.tryGetArray(sqlStatement.params);
        }
        if (sqlStatement.hasOwnProperty('options')) { // if options is provided, validate it
            SqlServiceImpl.validateSqlStatementOptions(sqlStatement.options);
        }
    }
    /**
     * Validates SqlStatementOptions
     *
     * @param sqlStatementOptions
     * @throws RangeError if validation is not successful
     * @internal
     */
    static validateSqlStatementOptions(sqlStatementOptions) {
        if (sqlStatementOptions.hasOwnProperty('schema')) {
            Util_1.tryGetString(sqlStatementOptions.schema);
        }
        if (sqlStatementOptions.hasOwnProperty('timeoutMillis')) {
            const timeoutMillis = Util_1.tryGetNumber(sqlStatementOptions.timeoutMillis);
            if (timeoutMillis < 0 && timeoutMillis !== -1) {
                throw new RangeError('Timeout millis can be non-negative or -1');
            }
        }
        if (sqlStatementOptions.hasOwnProperty('cursorBufferSize') && Util_1.tryGetNumber(sqlStatementOptions.cursorBufferSize) <= 0) {
            throw new RangeError('Cursor buffer size cannot be negative');
        }
        if (sqlStatementOptions.hasOwnProperty('expectedResultType')) {
            Util_1.tryGetEnum(SqlStatement_1.SqlExpectedResultType, sqlStatementOptions.expectedResultType);
        }
        if (sqlStatementOptions.hasOwnProperty('returnRawResult')) {
            Util_1.tryGetBoolean(sqlStatementOptions.returnRawResult);
        }
    }
    /**
     * Converts an error to HazelcastSqlException and returns it. Used by execute, close and fetch
     * @internal
     * @param err
     * @param connection
     * @returns {@link HazelcastSqlException}
     */
    toHazelcastSqlException(err, connection) {
        if (!connection.isAlive()) {
            return new core_1.HazelcastSqlException(connection.getRemoteUuid(), SqlErrorCode_1.SqlErrorCode.CONNECTION_PROBLEM, 'Cluster topology changed while a query was executed:' +
                `Member cannot be reached: ${connection.getRemoteAddress()}`, err);
        }
        else {
            if (err instanceof core_1.HazelcastSqlException) {
                return err;
            }
            let originatingMemberId;
            if (err.hasOwnProperty('originatingMemberId')) {
                originatingMemberId = err.originatingMemberId;
            }
            else {
                originatingMemberId = this.connectionManager.getClientUuid();
            }
            return new core_1.HazelcastSqlException(originatingMemberId, SqlErrorCode_1.SqlErrorCode.GENERIC, err.message, err);
        }
    }
    executeStatement(sqlStatement) {
        var _a, _b, _c, _d, _e;
        try {
            SqlServiceImpl.validateSqlStatement(sqlStatement);
        }
        catch (error) {
            throw new core_1.IllegalArgumentError(`Invalid argument given to execute(): ${error.message}`, error);
        }
        const connection = this.connectionRegistry.getRandomConnection(true);
        if (connection === null) {
            throw new core_1.HazelcastSqlException(this.connectionManager.getClientUuid(), SqlErrorCode_1.SqlErrorCode.CONNECTION_PROBLEM, 'Client is not currently connected to the cluster.');
        }
        const queryId = SqlQueryId_1.SqlQueryId.fromMemberId(connection.getRemoteUuid());
        const expectedResultType = ((_a = sqlStatement.options) === null || _a === void 0 ? void 0 : _a.hasOwnProperty('expectedResultType')) ?
            SqlStatement_1.SqlExpectedResultType[sqlStatement.options.expectedResultType] : SqlServiceImpl.DEFAULT_EXPECTED_RESULT_TYPE;
        let timeoutMillis;
        if ((_b = sqlStatement.options) === null || _b === void 0 ? void 0 : _b.hasOwnProperty('timeoutMillis')) {
            timeoutMillis = Long.fromNumber(sqlStatement.options.timeoutMillis);
        }
        else {
            timeoutMillis = SqlServiceImpl.DEFAULT_TIMEOUT;
        }
        try {
            let serializedParams;
            if (Array.isArray(sqlStatement.params)) { // params can be undefined
                serializedParams = new Array(sqlStatement.params.length);
                for (let i = 0; i < sqlStatement.params.length; i++) {
                    serializedParams[i] = this.serializationService.toData(sqlStatement.params[i]);
                }
            }
            else {
                serializedParams = [];
            }
            const cursorBufferSize = ((_c = sqlStatement.options) === null || _c === void 0 ? void 0 : _c.hasOwnProperty('cursorBufferSize')) ?
                sqlStatement.options.cursorBufferSize : SqlServiceImpl.DEFAULT_CURSOR_BUFFER_SIZE;
            const returnRawResult = ((_d = sqlStatement.options) === null || _d === void 0 ? void 0 : _d.hasOwnProperty('returnRawResult')) ?
                sqlStatement.options.returnRawResult : SqlServiceImpl.DEFAULT_FOR_RETURN_RAW_RESULT;
            const schema = ((_e = sqlStatement.options) === null || _e === void 0 ? void 0 : _e.hasOwnProperty('schema')) ?
                sqlStatement.options.schema : SqlServiceImpl.DEFAULT_SCHEMA;
            const requestMessage = SqlExecuteCodec_1.SqlExecuteCodec.encodeRequest(sqlStatement.sql, serializedParams, timeoutMillis, cursorBufferSize, schema, expectedResultType, queryId);
            const res = SqlResult_1.SqlResultImpl.newResult(this, this.serializationService, connection, queryId, cursorBufferSize, returnRawResult, this.connectionManager.getClientUuid());
            this.invocationService.invokeOnConnection(connection, requestMessage).then(clientMessage => {
                SqlServiceImpl.handleExecuteResponse(clientMessage, res);
            }).catch(err => {
                res.onExecuteError(this.toHazelcastSqlException(err, connection));
            });
            return res;
        }
        catch (error) {
            throw this.toHazelcastSqlException(error, connection);
        }
    }
    execute(sql, params, options) {
        const sqlStatement = {
            sql: sql
        };
        // If params is not provided it won't be validated. Default value for optional parameters is undefined.
        // So, if they are undefined we don't set it, and in validator method we check for property existence.
        if (params !== undefined) {
            sqlStatement.params = params;
        }
        if (options !== undefined) {
            sqlStatement.options = options;
        }
        return this.executeStatement(sqlStatement);
    }
    close(connection, queryId) {
        const requestMessage = SqlCloseCodec_1.SqlCloseCodec.encodeRequest(queryId);
        return this.invocationService.invokeOnConnection(connection, requestMessage);
    }
    fetch(connection, queryId, cursorBufferSize) {
        const requestMessage = SqlFetchCodec_1.SqlFetchCodec.encodeRequest(queryId, cursorBufferSize);
        return this.invocationService.invokeOnConnection(connection, requestMessage).then(clientMessage => {
            const response = SqlFetchCodec_1.SqlFetchCodec.decodeResponse(clientMessage);
            if (response.error !== null) {
                throw new core_1.HazelcastSqlException(response.error.originatingMemberId, response.error.code, response.error.message);
            }
            return response.rowPage;
        });
    }
}
exports.SqlServiceImpl = SqlServiceImpl;
/** Value for the timeout that is not set. */
SqlServiceImpl.TIMEOUT_NOT_SET = Long.fromInt(-1);
/** Default timeout. */
SqlServiceImpl.DEFAULT_TIMEOUT = SqlServiceImpl.TIMEOUT_NOT_SET;
/** Default cursor buffer size. */
SqlServiceImpl.DEFAULT_CURSOR_BUFFER_SIZE = 4096;
SqlServiceImpl.DEFAULT_FOR_RETURN_RAW_RESULT = false; // don't return raw result by default
SqlServiceImpl.DEFAULT_EXPECTED_RESULT_TYPE = SqlStatement_1.SqlExpectedResultType.ANY;
SqlServiceImpl.DEFAULT_SCHEMA = null;
//# sourceMappingURL=SqlService.js.map