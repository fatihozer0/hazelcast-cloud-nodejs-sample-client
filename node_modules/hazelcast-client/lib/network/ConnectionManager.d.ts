/** @ignore */ /** */
import { UUID, LoadBalancer } from '../core';
import { Connection } from './Connection';
import { ConnectionStrategyConfig } from '../config/ConnectionStrategyConfig';
import { ClusterService } from '../invocation/ClusterService';
declare enum ConnectionState {
    /**
     * Clients start with this state. Once a client connects to a cluster,
     * it directly switches to {@link INITIALIZED_ON_CLUSTER} instead of
     * {@link CONNECTED_TO_CLUSTER} because on startup a client has no
     * local state to send to the cluster.
     */
    INITIAL = 0,
    /**
     * When a client switches to a new cluster, it moves to this state.
     * It means that the client has connected to a new cluster but not sent
     * its local state to the new cluster yet.
     */
    CONNECTED_TO_CLUSTER = 1,
    /**
     * When a client sends its local state to the cluster it has connected,
     * it switches to this state. When a client loses all connections to
     * the current cluster and connects to a new cluster, its state goes
     * back to {@link CONNECTED_TO_CLUSTER}.
     * <p>
     * Invocations are allowed in this state.
     */
    INITIALIZED_ON_CLUSTER = 2
}
export interface ConnectionRegistry {
    /**
     * Returns if the registry active
     * @return Return true if the registry is active, false otherwise
     */
    isActive(): boolean;
    /**
     * Returns connection by UUID
     * @param uuid UUID that identifies the connection
     * @return Connection if there is a connection with the UUID, undefined otherwise
     */
    getConnection(uuid: UUID): Connection | undefined;
    /**
     * Returns all active connections in the registry
     * @return Array of Connection objects
     */
    getConnections(): Connection[];
    /**
     * Returns a random connection from active connections
     * @param dataMember true if only data members should be considered
     * @return Connection if there is at least one connection, otherwise null
     */
    getRandomConnection(dataMember?: boolean): Connection | null;
    /**
     * Returns if invocation allowed. Invocation is allowed only if connection state is {@link INITIALIZED_ON_CLUSTER}
     * and there is at least one active connection.
     * @return Error if invocation is not allowed, null otherwise
     */
    checkIfInvocationAllowed(): Error | null;
}
export declare class ConnectionRegistryImpl implements ConnectionRegistry {
    private active;
    private readonly activeConnections;
    private readonly loadBalancer;
    private connectionState;
    private readonly smartRoutingEnabled;
    private readonly asyncStart;
    private readonly reconnectMode;
    private readonly clusterService;
    constructor(connectionStrategy: ConnectionStrategyConfig, smartRoutingEnabled: boolean, loadBalancer: LoadBalancer, clusterService: ClusterService);
    isActive(): boolean;
    getConnectionState(): ConnectionState;
    isEmpty(): boolean;
    getConnections(): Connection[];
    getConnection(uuid: UUID): Connection | undefined;
    getRandomConnection(dataMember?: boolean): Connection | null;
    forEachConnection(fn: (conn: Connection) => void): void;
    checkIfInvocationAllowed(): Error | null;
    deleteConnection(uuid: UUID): void;
    /**
     * Adds or updates a client connection by uuid
     * @param uuid UUID to identify the connection
     * @param connection to set
     */
    setConnection(uuid: UUID, connection: Connection): void;
    setConnectionState(connectionState: ConnectionState): void;
    activate(): void;
    deactivate(): void;
}
export {};
