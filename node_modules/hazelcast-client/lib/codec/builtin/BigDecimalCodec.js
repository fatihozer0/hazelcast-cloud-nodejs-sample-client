"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BigDecimalCodec = void 0;
const CodecUtil_1 = require("./CodecUtil");
const FixSizedTypesCodec_1 = require("./FixSizedTypesCodec");
const BitsUtil_1 = require("../../util/BitsUtil");
/** @internal */
class BigDecimalCodec {
    static decode(clientMessage) {
        const buffer = clientMessage.nextFrame().content;
        const contentSize = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(buffer, 0);
        const body = buffer.slice(BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES, BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES + contentSize);
        const isNegative = (body[0] & 0x80) > 0;
        if (isNegative) { // negative, convert two's complement to positive
            for (let i = 0; i < body.length; i++) {
                body[i] = ~body[i];
            }
        }
        const hexString = '0x' + body.toString('hex');
        let bigint = BigInt(hexString);
        if (isNegative) {
            // When converting from 2 s complement, need to add 1 to the inverted bits.
            // Since adding 1 to a buffer is hard, it is done here.
            bigint += BigInt(1);
        }
        const bigIntString = bigint.toString();
        const scale = FixSizedTypesCodec_1.FixSizedTypesCodec.decodeInt(buffer, BitsUtil_1.BitsUtil.INT_SIZE_IN_BYTES + contentSize);
        return BigDecimalCodec.toScale(bigIntString, scale, isNegative);
    }
    static decodeNullable(clientMessage) {
        return CodecUtil_1.CodecUtil.nextFrameIsNullFrame(clientMessage) ? null : BigDecimalCodec.decode(clientMessage);
    }
    static toScale(bigIntString, scale, isNegative) {
        if (scale === 0) {
            return (isNegative ? '-' : '') + bigIntString;
        }
        else if (scale > 0) {
            if (scale < bigIntString.length) {
                return (isNegative ? '-' : '') + bigIntString.substring(0, bigIntString.length - scale) + '.'
                    + bigIntString.substring(bigIntString.length - scale);
            }
            else {
                const numberOfZerosAfterDecimal = scale - bigIntString.length;
                return (isNegative ? '-0.' : '0.') + '0'.repeat(numberOfZerosAfterDecimal) + bigIntString;
            }
        }
        else {
            return (isNegative ? '-' : '') + bigIntString + '0'.repeat(-1 * scale);
        }
    }
}
exports.BigDecimalCodec = BigDecimalCodec;
//# sourceMappingURL=BigDecimalCodec.js.map